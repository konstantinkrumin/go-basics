// Массив — это коллекция однотипных значений фиксированной длины:
nums := [5]int{}

/*
	Длина массива указывается в квадратных скобках. Если не заполнить массив при 
	инициализации, то массив будет состоять из нулевых значений данного типа:
*/
nums := [5]int{} // [0, 0, 0, 0, 0]

// длинная инициализация
var nums [5]int // [0, 0, 0, 0, 0]

// Чтение и запись элементов массива происходит через квадратные скобки:
nums := [3]int{1, 2, 3}

fmt.Println(nums[1]) // 2

nums[2] = 33

fmt.Println(nums) // [1, 2, 33]

/*
	Массивы в Go передаются по значению, следовательно, любое изменение внутри функции 
	не влияет на исходный массив:
*/
package main

import (
    "fmt"
)

func main() {
    a := [3]int{1,2,3}

    modifyArr(a)

    fmt.Println(a) // 1, 2, 3
}

func modifyArr(nums [3]int) {
    nums[0] = 35
}

// В Go есть встроенная функция len(), которая возвращает длину массива:
fmt.Println(len([5]int{1,2,3})) // 5
fmt.Println(len([10]int{})) // 10

/* ========================= */
/*
	Реализуйте функцию SafeWrite(nums [5]int, i, val int) [5]int, которая записывает 
	значение val в массив nums по индексу i, если индекс находится в рамках массива. 
	В противном случае массив возвращается без изменения.
*/
package solution

func SafeWrite(nums [5]int, i, val int) [5]int {
	if (i < 0 || i > len(nums) - 1) {
		return nums
	}

	newNums := nums
	newNums[i] = val
	return newNums
}
