/*
	Допустим, в вашей функции происходят изменения элементов, но вы не хотите затронуть 
	входной слайс. В языке есть встроенная функция func copy(dst, src []Type) int, 
	которая копирует слайс src в слайс dst и возвращает кол-во скопированных элементов:
*/
nums := []int{1,2,3,4,5}

// важно инициализировать слайс той же длины
numsCp := make([]int, len(nums))

copy(numsCp, nums)

fmt.Println(numsCp) // [1,2,3,4,5]

/*
	Почему мы не можем просто перезаписать слайс в другую переменную и изменять ее? 
	Как и с функциями, при присваивании слайса к переменной, копируется только длина 
	и вместимость, но массив передается по ссылке:
*/
nums := []int{1,2,3,4,5}

numsCp := nums

// исходный слайс nums тоже будет изменен
numsCp[0] = 10

fmt.Println(nums) // [10,2,3,4,5]

/*
	Существует распространенная ошибка, когда пытаются скопировать слайсы различной длины. 
	В этом случае элементы, выходящие за рамки слайса dst, не будут скопированы:
*/
nums := []int{1, 2, 3, 4, 5}

// создали слайс с длиной 0
numsCp := make([]int, 0)

// при копировании в пустой слайс ничего не произойдет
copy(numsCp, nums)

fmt.Println(numsCp) // []

/* ========================= */
/*
	Реализуйте функцию IntsCopy(src []int, maxLen int) []int, которая создает копию слайса 
	src с длиной maxLen. Если maxLen равен нулю или отрицательный, то функция возвращает 
	пустой слайс []int{}. Если maxLen больше длины src, то возвращается полная копия src.
*/
func IntsCopy(src []int, maxLen int) []int {
	if maxLen <= 0 {
		return []int{}
	}

	if maxLen > len(src) {
		return src
	}

	dst := make([]int, maxLen)
	copy(dst, src)
	return dst
}